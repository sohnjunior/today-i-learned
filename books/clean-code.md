> 💡 클린코드를 읽고 요약한 내용입니다.

## 7. 오류 처리

### 오류 코드 대신 예외를 throw 하라

논리와 오류 처리 코드를 분리할 수 있다.

### 예외처리가 필요한 로직은 try-catch-finally 부터 작성하라

그러면 try 블록의 트랜잭션 범위부터 구현하게 되어 트랜잭션 본질을 유지하기 쉽다.  
이 경우에도 실패 테스트케이스부터 정의한다.

### 미확인 예외를 사용하라
확인된 예외는 `개방폐쇄원칙` 을 위배한다.  

### 예외에 의미를 부여하라
예외를 던질때는 호출스택, 상세한 에러 메시지들을 포함시켜준다.  

### 특수사례객체를 활용하라
정상 흐름에 문제가 있을 때 항상 예외를 던지는 것이 좋을까?  
`특수사례객체` 도 좋은 옵션이다.  
`0, []` 등의 특수한 케이스를 반환하는 것이다.  
이를 활용하면 사용하는 쪽에서는 별도의 예외처리가 필요 없고, 간결한 코드를 유지할 수 있다.  


## 8. 경계

이번장에서는 `경계 인터페이스` 에 대해서 다룬다.  
`경계 인터페이스` 는 빌트인 객체가 될 수도 있고, 외부 패키지가 될 수도 있겠다.  

### 경계 인터페이스를 여기저기 넘기지 않기

항상 경계를 감싸야 한다는 것이 아니다.  
중요한 것은 어떠한 목적으로 사용되고 있는 경계 인터페이스를 여기저기 인수로 전달하지 않는 것이다.  

### 경계 인터페이스 감싸기

이러한 상황을 방지하기 위해 경계 인터페이스를 감싸는 래퍼 클래스를 만들 수 있다.  
일종의 `어댑터 패턴` 인 것이다.  

이러한 추상화를 통해서 아직 확인되지 않은 외부 코드의 기대 동작을 미리 정의해서 개발 할 수 있고, `학습 테스트` 를 통해서 외부 코드를 도입하기 전에 사용법을 익히고 안전하게 우리의 코드 베이스에 녹일 수 있다.  

또한 외부 인터페이스 변경에 유연하게 대처할 수 있고, 새로운 패키지로의 전환이 용이하다.  

## 9. 단위 테스트

### TDD 법칙 3가지

1. 실패하는 테스트 코드를 작성하기 전까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도의 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과하는 정도의 코드를 구현한다.

### 테스트 코드는 항상 깨끗하게 유지하자
지저분한 테스트 코드는 생산성을 오히려 저해시키는 요소이다.  


### 테스트 코드를 깨끗하게 유지하는 원칙
#### 본인만의 테스트 API 구현하기
테스트 코드를 리팩토링하다보면 반복되는 부분이 생길 수 있다.  
이런 경우 내부에 실제 테스트 API 를 숨기고 추상화를 제공하는 API 들을 만들어서 사용해보자  

#### 테스트 당 assert 는 최소한으로
무조건 1개의 assert 를 사용해야한다는 것이 아니다.  
하지만 되도록이면 assert 를 줄이는 것이 좋겠다.
중요한건 언제나 중복 최소와 가독성이다.  

#### 테스트 당 개념 하나
중요한건 테스트 케이스당 개념 1가지를 테스트해야한다는 것이다.  
여러 개념을 한곳에서 테스트하면 가독성도 안좋고 핵심에 집중하기 어렵다.

#### `F.I.R.S.T` 를 기억하자  

Fast, Independant, Repeatable, Self-Validating, Timely

테스트는 빠르고 상호 독립적으로 수행되어야하며 어느 상황에서든 반복 가능해야한다.  
또한 bool 값으로 성공/실패를 구분하며 실제 코드를 구현하기 직전에 테스트 코드를 구현한다.

## 10. 클래스

### 클래스는 작게!
클래스를 구현할 때 가장 중요한 것은 작게 구현하는 것이다.  
클래스가 작다는 것은 하나의 `책임` 만을 가진다는 것이다. (단일책임원칙)  

### 작은 클래스로 쪼개는 것을 망설이지 말자
함수를 작게 나누다보면 상위 함수에서 사용하는 변수를 인수로 넘겨줘야하는 경우가 생긴다.  
이때 인수로 넘기지 않고 클래스 인스턴스 변수로 승격하면 인수를 넘겨주지 않아도 된다.  

그런데 이렇게하면 클래스가 응집력을 잃게되는데, 이 때 몇몇 함수만 사용하는 변수와 함께 `독자적인 클래스` 로 분리하자.  
결국 메서드를 쪼개다보면 `작은 클래스` 여러개로 분리되기 마련이다.

### 변경으로부터 격리하자
`개방폐쇄원칙(OCP)` 과 `의존성역전(DIP)` 를 기억하자

`OCP` 는 클래스는 확장에 개방적이고 수정에 폐쇄적이어야한다는 것이다.  
`DIP` 는 클래스는 상세한 구현이 아니라 추상화에 의존해야한다는 것이다.


## 11. 시스템

이번 장에서는 주로 Java 생태계의 예시들이 많아서 이해하기 조금 어려웠다. 😂  

### 의존성 분리
시스템 사용과 시스템 생성을 분리하라.  
이를 활용하는 강력한 매커니즘 중 하나는 `의존성 주입` 이다.  
의존성 주입은 제어 역전 기법을 이용해서 한 객체가 맡은 보조 책임을 새로운 객체로 넘긴다.  
이때 새로운 객체는 넘겨받은 책임만 맡으면 되므로 자연스럽게 `단일 책임 원칙` 을 지킨다.  

### 시스템은 깨끗해야한다.
시스템은 깨끗해야한다. 깨끗하지 못한 아키텍쳐는 도메인 논리를 흐린다.  
이로 인해 버그가 스며들기 쉬워지고 생산성이 낮아진다.  
모든 추상화 단계에서 의도는 명확해야한다.  

## 12. 창발성

켄트 벡은 다음 4가지 설계 원칙을 준수하면 소프트웨어 설계 품질을 크게 높일 수 있다고 말한다.  

- 모든 테스트를 수행한다.  
  - 테스트 가능한 코드를 만들려고 하면 설계 품질이 자연스럽게 높아진다.
- 중복을 없앤다.
  - 중복은 유지보수성을 낮춘다.
  - 자주 리팩토링해 개선의 여지를 충분히 만들자.
- 프로그래머 의도를 표현한다.
  - 자신이 이해하는 코드가 아니라 남이 이해할 수 있는 명확한 코드를 작성하자.
  - 변수명, 함수와 클래스의 크기 줄이기, 업계 표준 명칭, 단위 테스트 등을 꼼꼼히 챙기자.
- 클래스와 메서드 수를 최소로 줄인다.
  - 클래스와 메서드를 불필요하게 작게 나누는 것도 문제이다.
  - 꼭 필요한 클래스와 메서드를 응집도 있게, SRP 를 준수하며 나누도록 노력하자.
  - 뭐든지 과하면 독이다.

