# [You Don’t Know JS] CH.6 스코프와 클로저

## 📌 스코프란 무엇인가?

### 자바스크립트 코드 실행 과정

먼저 `스코프` 에 대해서 자세히 살펴보기 전에 실제로 자바스크립트 파일이 어떤 과정을 거쳐 

실행되는 것인지에 대한 대략적인 이해가 필요합니다.

어떤 자바스크립트 코드라도 실행을 위해서는 `컴파일` 과정이 필요합니다.

자바스크립트 엔진이 다른 언어의 컴파일러와 다른점은 컴파일을 미리 수행하지 않아서

최적화할 충분한 시간이 존재하지 않다는 것입니다.

(이를 위해 `Lazy compile` 이나 `Hot Recompile` 등을 통해 최적화를 수행합니다.)

컴파일은 다음의 과정을 거쳐 수행됩니다.

```markdown
* 토크나이징
* 파싱
* 코드 생성 및 실행
```

`토크나이징` 에서 의미있는 조각으로 만들고 `파싱` 과정을 통해 `AST` 를 생성한 뒤,

생성된 `AST` 를 기반으로 실행코드를 만들고 프로그램을 실행합니다.

### 스코프의 역할

코드 실행에 있어서 `스코프` 의 역할을 살펴보기 위해 다음 코드를 예시로 들겠습니다.

```jsx
var a = 2;
```

여기서 등장하는 세가지 주역들은 각각 `엔진` , `컴파일러` , `스코프` 입니다.

`스코프` 는 엔진을 도와 선언된 모든 변수(확인자) 목록을 관리하며 변수 적용 방식을 정합니다.

위 세가지 친구들은 `var a = 2` 라는 코드를 다음과 같이 처리합니다.

1. 컴파일러가 스코프에게 `a` 가 스코프 컬렉션이 존재하는지 묻습니다.
2. 만약 변수 `a` 가 이미 존재하면 그냥 지나가고 아니면 새로운 변수 `a` 를 컬렉션에 선언하라고 요청합니다.
3. 이후 컴파일러는 `a = 2` 를 수행하기 위한 코드를 생성합니다.
4. 엔진은 코드를 실행할 때 스코프에게 `a` 가 현재 스코프 컬렉션에서 접근 가능한지 확인합니다.
5. `a` 가 존재한다면 사용하고 그렇지 않다면 다른 스코프를 살핍니다.

`스코프` 는 한마디로 **특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데 사용하는 규칙**이라고 할 수 있습니다.

### 컴파일러 관련 용어 (LHS, RHS)

엔진이 코드를 실행할 때 어떤 종류의 검색을 수행하는지에 따라 결과가 달라집니다.

여기서 `LHS` 와 `RHS` 의 차이가 발생하는데, 각각 다음과 같습니다.

- `LHS` : 대입할 대상을 찾는 검색 타입 (ex. `=` 연산자의 왼쪽에 변수가 존재하는 경우)
- `RHS` : 대입한 값을 찾는 검색 타입 (ex. `=` 연산자의 오른쪽에 변수가 존재하는 경우)

예시 코드를 통해 위 두 검색 타입이 어떤 식으로 활용되는지 살펴보겠습니다.

```jsx
function foo(a) {
	console.log(a)
}

foo(2)
```

```markdown
엔진 : 안녕 스코프, `foo` 에 대한 RHS 참조가 필요해. 

스코프 : 응, 잠시만! 컴파일러가 좀 전에 선언했어. `foo` 는 함수야.

엔진 : 좋아, 이제 `foo` 를 실행해야겠다.

엔진 : 이봐 스코프, `a` 에 대한 LHS 참조도 필요해. 들어봤니?

스코프 : 물론, 컴파일러가 `a` 를 `foo` 의 인자로 방금 선언했어.

엔진 : 고마워, 이제 `2` 를 `a` 에 대입할게.

엔진 : 스코프, `console` 에 대한 RHS 검색이 필요해.

스코프 : 자, `console` 을 찾았어. window 에 내장되어있더라.

엔진 : 좋아, 이제 `log` 를 찾아야겠다. 이건 함수구나!

엔진 : 스코프, `a` 의 RHS 참조를 찾는 것을 도와줄래?

스코프 : 여기 있어.

엔진 : 좋아, 이제 `a` 의 값은 2이고.. 이걸 log 에 넘기자

...
```

## 📌 렉시컬 스코프

스코프는 두 가지 방식으로 동작합니다.

하나는 `동적 스코프` 이고 다른 하나는 `렉시컬 스코프` 입니다.

자바스크립트는 `렉시컬 스코프` 로 동작하며 이는 곧 `렉싱 타임` 에 정의되는 스코프를 의미합니다.

즉 개발자가 코드를 작성할 때 변수와 스코프 블록을 어디에 정의하는가에 기초해

렉서가 코드를 처리할 때 스코프가 정의됩니다.

어떤 함수가 어떻게 혹은 어디서 호출되는지와 상관없이 함수의 `렉시컬 스코프` 는 

해당 함수가 선언된 위치에 따라 결정됩니다.

### 렉시컬 속이기

렉시컬을 속일 수 있는 두 가지 방법이 존재합니다.

두 방법 모두 성능상이 이유로 사용을 하지 않는 것이 좋습니다.

1️⃣  **eval 함수**

`eval` 함수는 인자로 받은 문자열의 내용을 처음부터 그 자리에 존재하는 코드처럼 처리합니다.

그리고 이 과정에서 렉시컬 스코프를 수정하게 됩니다.

```jsx
function foo(str, a) {
	eval(str)
	console.log(a, b)
}

var b = 2
foo("var b = 3", 1); // 1, 3
```

위 예제 코드의 경우 `var b = 3` 을 `eval` 로 실행하면서 `foo` 의 렉시컬 스코프를 수정합니다.

따라서 `foo` 스코프에 `b` 가 존재하는 것으로 인식되어 글로벌 스코프의 `b` 를 검색하지 않습니다.

2️⃣  **with 구문**

`with` 구문은 인자로 받은 객체를 이용해서 새로운 `렉시컬 스코프` 를 생성합니다.

이때 생길 수 있는 특이한 부작용에 대해서 주의해야합니다.

```jsx
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = { a: 3 }

var o2 = { b: 3 }

foo(o1);
console.log(o1.a) // 2

foo(o2);
console.log(o2.a) // undefined
console.log(a) // 2 🤔 ..?
```

위 예시에서 `foo` 는 인자로 받은 `obj` 를 `with` 구문을 이용해 속성값을 변경하고 있습니다.

그런데 실행결과를 살펴보면 `window.a` 에 `2` 라는 새로운 값이 할당되어있습니다.

왜 이런 일이 생긴 것일까요?

이는 `o2` 가 스코프로 사용될때 `a` 확인자가 없기 때문에 `LHS` 확인자 검색 규칙이 사용되기 때문입니다.

`o2` 의 스코프, `foo` 의 스코프 그리고 최종적으로 글로벌 스코프에서도 `a` 를 찾을 수 없기 때문에

`a = 2` 가 수행되면서 그에 해당하는 글로벌 변수가 생긴 것입니다.

<aside>
💡 **이 두 방법모두 성능상의 이유로 사용을 권하지 않습니다.**

이는 JS 엔진이 컴파일단계에서 상당수의 최적화 작업을 진행하는데
이 과정에서 코드의 모든 변수와 선언문의 위치를 파악하고 
이를 통해 확인자 검색을 빠르게 하는 작업이 포함됩니다.

만약 `eval` 이나 `with` 를 이용하는 코드가 있다면 엔진이 미리 파악한 확인자의 위치가
달라질 가능성이 있는 것이기 때문에 최적화 작업이 의미없어 지는 것이 됩니다.

</aside>

## 📌 함수 & 블록 스코프

자바스크립트에는 `함수 스코프` 와 `블록 스코프` 가 존재합니다.

함수 스코프는 모든 변수가 함수에 속하고 함수 전체에 걸쳐 사용되며 재사용된다는 개념을 확고히합니다.

### 스코프에 숨기기

스코프를 이용해서 숨기는 방법은 `최소 권한의 원칙` 에 따른 몇가지 장점이 있습니다.

이 원칙은 SW 를 설계할 때 모듈 및 객체의 API 와 같은 것들을 설계할 때 

필요한 것만 최소한으로 남기고 나머지는 숨기도록 합니다.

`스코프` 는 이러한 원칙과 직접적인 연관이 있습니다.

다음은 중첩된 스코프에 대한 간단한 예시입니다.

```jsx
function doSomething(a) {
	b = a + doSomethingElse(a * 2);

	console.log(b * 3);
}

function doSomethingElse(a) {
	return a - 1;
}

var b;
doSomething(2);
```

이 경우 변수 `b` 와 함수 `doSomethingElse` 는 `doSomething` 의 내부에서만 사용되는 로직입니다.

따라서 이 둘은 `doSomething` 의 내부로 감추어 외부에서 접근 불가능하도록 하는것이 더 나은 설계입니다.

```jsx
function doSomething(a) {
	function doSomethingElse(a) {
		return a - 1;
	}

	var b;
	b = a + doSometingElse(a * 2);
	console.log(b * 3);
}

doSomething(2);
```

뿐만 아니라 적절한 `스코프` 를 통해서 식별자 간 `충돌 방지` 가 가능합니다.

전역 네임스페이스가 오염되는 것을 방지하기 위해 이 방법이 사용될 수도 있고

좀 더 현대적인 방법은 `모듈 관리` 를 통해서 이 문제를 해결하는 방법이 있습니다.

### 함수 스코프와 블록 스코프

자바스크립트에는 `함수 스코프` 와 `블록 스코프` 가 존재합니다.

과거 `var` 로 변수를 선언하던 시절, 자바스크립트는 고질적인 스코프 문제를 해결하기 위해

다음과 같이 즉시실행함수(IIFE) 를 활용했습니다.

```jsx
(function foo() {
	var a = 3;
	console.log(a);
})()
```

이렇게하면 스코프 오염 문제없이 함수를 실행할 수 있습니다.

`ES6` 에 들어서는 `var` 변수 선언 대신 `let` 과 `const` 를 활용한 변수 선언이 추가되었습니다.

이를 활용하면 `블록 스코프` 로 변수를 선언할 수 있어 유용합니다.

`let` 과 `const` 는 선언된 변수를 둘러싼 가장 가까운 아무 블록의 스코프에 붙입니다.

## 📌 호이스팅

변수와 함수 선언문이 선언된 위치에서 코드 최상단으로 끌어올려지는 것을 `호이스팅` 이라고 합니다.

예를 들어 다음과 같은 코드가 있다면,

```jsx
a = 2;
var a;
console.log(a);
```

마지막 `console.log` 에서 undefined 대신에 `2` 가 출력됩니다.

이는 `var` 가 호이스팅의 영향을 받기 때문인데, 위 코드는 아래와 같이 변형된다고 볼 수 있습니다.

```jsx
var a;
a = 2;
console.log(a);
```

호이스팅은 `스코프` 별로 동작하며, 함수 선언문은 변수 선언문보다 우선순위가 높습니다.

## 📌 스코프 클로저

`클로저` 는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도

이 스코프에 접근할 수 있게 하는 기능입니다.

`클로저` 를 가장 잘 설명하는 예시는 반복문과 타이머 함수입니다.

```jsx
for (var i = 1; i <= 5; i++) {
	setTimeout(function timer() { console.log(i) }, i * 1000)
}
```

위 코드를 실행해보면 `6` 만 5번 실행되는 것을 알 수 있습니다.

이는 각각의 반복문이 실행될 때 모두 같은 글로벌 스코프를 공유하기 때문입니다.

이 때문에 글로벌 스코프에 존재하는 같은 `i` 값을 참조하게 되는 것입니다.

이 문제를 해결하기 위해서는 각각의 반복문이 별도의 스코프에 묶이도록 해야합니다.

이를 위해 `ES6` 에 도입된 `let` 을 이용해서 변수를 선언해주면 됩니다.

`let` 은 본질적으로 하나의 블록을 닫을 수 있는 스코프로 바꿉니다.

```jsx
for (let i = 1; i <= 5; i++) {
	// ...
}
```
